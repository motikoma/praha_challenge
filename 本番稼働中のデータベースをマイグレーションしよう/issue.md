# 課題１（質問）

## Expand and Contract Pattern"（または "Parallel Change"）

- システムやソフトウェアのマイグレーションを段階的に実施していくパターンで、特にリファクタリングやシステムの改善、マイクロサービスへの移行などによく用いられる
- このパターンの主な手法は以下の 3 ステップで構成される
- Expand： 既存の機能（コード、システム、データベースのスキーマなど）をそのままに、新しい機能やシステムを追加する。この時点では新旧の機能が共存する。
- Transition： 次に、新しい機能やシステムに移行する。この移行は段階的に行われることが一般的で、全てのコンポーネントやサービスが新しい機能に適応するまで、旧の機能やシステムは動作し続ける。
- Contract： 全てのコンポーネントやサービスが新しい機能やシステムに完全に移行したら、旧の機能やシステムを削除する。これによりシステムが収束（contract）する。
- このパターンの目的は、大きな変更を行う際にもサービスの運用を継続し、変更によるリスクを最小化すること
- "Expand and Contract Pattern"は、一度にすべてを変更するのではなく、段階的に進めることで、各段階で問題が発生した場合の影響を局所化し、ロールバックも容易にする。

参考：https://www.prisma.io/dataguide/types/relational/expand-and-contract-pattern

## 開発環境でマイグレーションを実施した時は問題なかったのに、本番環境で実施したら失敗する場合の原因と対策

- 開発環境と本番環境でマイグレーションの結果が異なる原因として、環境間のデータの違いが大きな要因となる
- 特に、既存のテーブルのカラムに NOT NULL 制約を追加しようとしたとき、そのカラムに NULL 値が存在していた場合、マイグレーションは失敗する
- 開発環境では通常、テストデータを使用しており、本番環境の全てのケースを網羅していないことが多い
- そのため、本番環境にのみ存在する NULL 値により、本番環境でのみマイグレーションが失敗するという状況が発生する
- この問題を避けるためには以下のような対策が考えられる

### データのクリーニング

- マイグレーションを適用する前に、NULL 値が存在する可能性があるカラムを対象にデータのクリーニングを行う
- NULL 値を適切なデフォルト値に置き換えることで、NOT NULL 制約の追加によるマイグレーションの失敗を防ぐ

### マイグレーションの段階的実行

- 大きなマイグレーションを一度に実行するのではなく、小さなステップに分けて実行する
- 例えば、最初に NULL 値をデフォルト値に置き換えるマイグレーションを実行し、次に NOT NULL 制約を追加するマイグレーションを実行する

# 課題２（実装）

マイグレーションに限らず本番環境で何らかの作業を行う際は作業手順書を作成しておくことが多いでしょう。 自分以外の開発者でも実行できるように丁寧に手順を書き出すのみならず、事前に想定し得る問題を列挙して、いざ問題が発生したときの対応手順を書き出しておくと安心です。何か不具合が起きて、怒鳴られたり対応を急かされながら対応策を考えると余計にミスをしてしまうので...
特大課題でモデリングしたプラハチャレンジのアプリケーションに仕様変更があり、ユーザが複数のペアに所属できるようになりました

この作りに対応するためにはデータベースのスキーマを変更する必要がありそうです
マイグレーションの作業手順書を作成してください。最低限以下の点を抑えておきましょう！
実行手順をステップごとに細かく列挙
例：本番環境で実行するコマンドは作業手順書からコピペするだけで完結するような状態になっていると良いですね！（コピペしたコマンドを全て開発環境で一度実行して動作確認まで済ませていると最高）

発生しうる問題
問題が発生したときの対応策
使うツールは問いません。HackMD でも notion でも！
上記以外に、どのような情報を手順書に残しておくと良いでしょうか?

## マイグレーション手順書

### マイグレーションの実行手順

1. Prisma のスキーマファイルを更新する

- 既存の User モデルと Pair モデルがあると仮定して、新しい中間テーブルとして UserPair を作成

```
model User {
  id      Int       @id @default(autoincrement())
  name    String
  pairs   UserPair[]
}

model Pair {
  id      Int       @id @default(autoincrement())
  name    String
  users   UserPair[]
}

model UserPair {
  id     Int  @id @default(autoincrement())
  userId Int
  pairId Int
  user   User @relation(fields: [userId], references: [id])
  pair   Pair @relation(fields: [pairId], references: [id])
}
```

2. Prisma マイグレーションの作成

- 次にマイグレーションを生成します。この操作はデータベースに変更を加えるわけではなく、実行すべき SQL コマンドを含むマイグレーションファイルを生成する
- prisma/migrations フォルダ内に新たなマイグレーションファイルが作成される

```
npx prisma migrate dev --create-only --name add-user-pair-association
```

3. 変更をコミットし、リモートリポジトリにプッシュする

- マイグレーションファイルを git でコミットし、リモートリポジトリにプッシュする

4. 本番環境でマイグレーションを適用する

```
npx prisma migrate deploy
```

### ロールバック手順書

0. Dev 環境で確認した前提ではあるが、本番環境と差分がある場合は失敗する可能性がある
1. 本番環境でアプリケーションの修正を実施し、UserPair を参照しなくても正常に動作するように修正する
2. Prisma はデフォルトでダウンマイグレーション（ロールバック）をサポートしていないため、ロールバック手順は手動で行う必要がある
3. 問題が発生したマイグレーションを特定する
4. ロールバック用として問題のマイグレーションで行われた変更を逆に適用する操作を記述したマイグレーションファイルを作成する

- 下記のモデル定義を schema.prisma から削除した後に、マイグレーションファイルを作成する

```
model UserPair {
  id     Int  @id @default(autoincrement())
  userId Int
  pairId Int
  user   User @relation(fields: [userId], references: [id])
  pair   Pair @relation(fields: [pairId], references: [id])
}
```

```
npx prisma migrate dev --create-only --name remove-user-pair-association
```

5. ロールバック用のマイグレーションを適用する

```
npx prisma migrate deploy
```
