# 課題 1

## Suspense とは

- React の Suspense は、React がコンポーネントツリーのレンダリングを一時停止し、それを非同期的に再開できるようにする機能
- つまり、非同期データの取得を待つことができる

```
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

## Suspense が React16 で導入された当時、一体どんな問題を解決するために登場したか？

### コードスプリッティングの複雑さ

- React アプリケーションが大きくなると、すべてのコードを一度にロードするのは非効率的で、アプリケーションの初期ロード時間が長くなる
- そのため、コードスプリッティング（必要なコードだけをロードする）が重要になる
- しかし、ロード状態の管理やエラーハンドリングなど、新たな複雑さをもたらす。
- 例えば、読み込みの順序を乱雑に感じさせ、ブラウザに不必要なレイアウト作業をさせ、アプリの読み込みを遅くさせる
- この API の目標は、特定のコンポーネントが根に近いか葉に近いかに関係なく、簡単にコードスプリッティングできるようにすること
- Suspense を組み合わせると、非同期にロードされるコンポーネントが準備できるまでの間、一時的に表示するコンテンツ（フォールバックコンテンツ）を定義できる
- これにより、ユーザーは何かがロード中であることを認識でき、より良いユーザーエクスペリエンスを提供できる

### 参考文献

- https://ja.legacy.reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html
- https://github.com/acdlite/rfcs/blob/first-class-promises/text/0064-lazy.md

## React18 で Suspense がどのような進化を遂げたのか調べてみましょう。なぜこのような形に進化したのか？

### 進化

サマリー

- 振る舞いの変化：コミットされたツリーは常に一貫している
  - コンポーネントツリーが準備できていない場合は破棄され、後で完全なツリーを挿入しようとする。
- 新機能：ストリーミングによるサーバーサイドレンダリングのサポート
- 新機能：トランジションを使って、既存のコンテンツを隠さない
  - 新しい UI が準備されている間、「古い」UI を表示した方が良い場合に対応できる
- 振る舞いの変化：コンテンツの再表示時にレイアウトエフェクトを再実行

動機

- React 16.6.0 での最初のリリースでは、Suspense は単一のユースケース、つまり React.lazy を使ったクライアントでのコード分割しかサポートしていなかった。
- コンポーネントツリーに<Suspense>境界を追加することはできても、それ以外の目的で React に利用されることはなかった
- さらに、サーバーレンダリングでも使用することができなかった。そのため、その有用性は非常に限られていた。
- 最終的には、同じ宣言型の Suspense フォールバックであらゆる非同期操作（コード、データ、画像などの読み込み）を処理できるように、サポートを拡張することが常に最大の動機
- Suspense のビジョンについては、React 18 の Keynote で詳しく説明されている
- https://www.youtube.com/watch?v=FZ0cG47msEk&t=409s

### 参考文献

- https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md#motivation

# 課題 2

## 「Suspense を使用しなくても、ローディング状態の制御は個々のコンポーネントに任せればよいのでは？」に対する回答

- Suspense を使えば各コンポーネントでローディング状態を制御するためのコードを書く量が減少する
- Suspense を使う方がローディング状態のレンダリングが最適化される

## 「Suspense が逆に邪魔な時ってないんですか？0.3 秒だけ時間がかかる中途半端な処理の間に fallback（グルグルアイコン）が表示されると、画面がチラついて鬱陶しいと思うんですけど」に対する回答

- useTransition を使えば、既存のコンポーネントを表示し続けることができるため。中途半端な処理の間に fallback（グルグルアイコン）が表示されることを防ぐことができる
- https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md#providing-immediate-feedback

## 「Suspense って SSR してるアプリケーションだったら意味をなさないんですかね？一度データを全部取得して、HTML にレンダリングしてからブラウザに返すし」に対する回答

- ページの一部がサーバー上で遅い場合でも、ユーザーには徐々にロードされるページが表示されるようになる
- すべてのコード分割チャンクの読み込みが終了するのを待つ必要がなくなるため、パフォーマンスを大幅に向上させることができる
- https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md#new-feature-server-side-rendering-support-with-streaming

## 「Suspense って React にとって結構大掛かりな変更だと思うんですけど、ユーザーがデータ取得を待つ間にサービスを触れるようにするためだけに、そこまでする必要あります？」

- React の API はプログラミングではなく設計原則に根ざしている
- Suspense を使えばデータの読み込みとローディング状態の管理を分離して実装することができる
- 宣言的かつシンプルになるため、コードのメンテナンス性が向上する
- デザイナーも実装できるようになる
- https://www.youtube.com/watch?v=FZ0cG47msEk&t=409s

# 課題 3

## 直近であなたが「なんか新しいから使ってみるか」と採用した技術に関して上記のアプローチから、その必要性を再検討する

### 技術

- Next.js App Router

### その技術が解決したい課題は何なのか

- 開発者がよりパフォーマンスが高く、機能が豊富な Web アプリケーションを簡単に構築できるようにしたい
- App Router は、React の最新機能を使ってアプリケーションを構築するための新しいパラダイム
- 既存のファイルシステムベースのルーターである Pages Router の自然な進化形

### どういう背景からその技術が生まれたのか

- React Server Components は、サーバーとクライアントを活用するハイブリッドアプリケーションを構築するための新しいメンタルモデル
- App Router はそれをサポートするために生まれた
- React Server Components への移行を容易にするために、App Router 内のすべてのコンポーネントは特殊ファイルや同じ場所に配置されたコンポーネントを含め、デフォルトで React Server Components になる。
- これにより、追加の作業を行わずにそれらを自動的に採用し、すぐに優れたパフォーマンスを実現できる。

### その技術に対して挙げた反証的な疑問

Pages Router から App Router にすぐに移行するべきか？

- 現状の Pages Router で問題がない場合、特に移行する必要はない
- ルーティングロジックが複雑になっている、または特定のパフォーマンス問題がある場合、App Router への移行は価値がある

### 参考文献

- https://nextjs.org/blog/layouts-rfc
