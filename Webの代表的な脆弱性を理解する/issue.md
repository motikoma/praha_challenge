# 課題１（質問）

## XSS（Cross-Site Scripting）

### 仕組み

- XSS 攻撃では、攻撃者はユーザーからの入力がウェブページに組み込まれることを利用して、スクリプトを埋め込む
- 攻撃者が提供したスクリプトは、ブラウザによって読み込まれ、実行される

### 発生し得る被害

- セッションハイジャック
  - 攻撃者は、ユーザーのセッションクッキーを盗むことができる
  - 攻撃者はユーザーとしてシステムにログインし、そのユーザーとして行動することができる
- データの窃取
  - 攻撃者は、ページ上のデータを読み取ったり、ユーザーが入力した情報を窃取したりすることができる
- マルウェアの拡散
  - 攻撃者は、ユーザーのブラウザ上でマルウェアをダウンロードまたは実行させることができる

### 対処法

- 入力の検証
  - ユーザーからの入力は、常に信用できないものとみなし、適切に検証する必要がある
- 出力のエスケープ
  - ユーザーからの入力をそのままウェブページに埋め込む前に、適切にエスケープ（特殊文字を無害な形に変換）することで、スクリプトの実行を防ぐ
- コンテンツセキュリティポリシー (CSP)
  - CSP を設定することで、ウェブページがどのスクリプトを実行することが許可されているかをブラウザに指示することができる
- HTTP-only クッキー
  - クッキーに HTTP-only 属性を設定すると、JavaScript からそのクッキーを読み取ることができなくなる
  - セッションハイジャックを防ぐのに有効な手段。ただし、この設定だけで XSS 攻撃全体を防げるわけではない
- 安全なライブラリ/フレームワークの利用
  - React や Angular などの現代的なフレームワークは、デフォルトで XSS 対策を提供している
  - ただし、これらの機能を無効にするか、誤って安全でない方法を使うと、依然として XSS のリスクが存在する

## コマンドインジェクション

### 仕組み

- アプリケーションがユーザからの入力を元にシステムコマンドを実行する場合、その入力値が適切に検証またはエスケープされていないと、攻撃者が意図しないコマンドを実行できる可能性がある

### 発生し得る被害

- システムの設定を変更し、システムを不安定にする。
- システム上のデータを改ざん、削除、または窃取
- そのシステムを制御下に置き、他のシステムに対する攻撃の拠点とする

### 対処法

- ユーザー入力の検証とサニタイズ

  - ユーザーからの入力は常に不信頼とみなし、適切にエスケープまたはサニタイズする
  - 可能な限りユーザ入力をコマンド実行に使用しないようにし、必要な場合は最小限に留め、厳密なホワイトリスト方式で入力を検証する

- パラメータ化された API の使用

  - シェルコマンドを直接実行する代わりに、可能な限りパラメータ化された API を使用する
  - これにより、悪意のある入力がコマンドとして実行される可能性を減らす

- 最小権限の原則
  - アプリケーションが必要とする権限だけを付与し、それ以上の権限を持たせないようにする
  - 攻撃者が成功した場合でも、彼らがシステム上でできることを最小限に制限することができる

## SQL インジェクション

### 仕組み

- SQL インジェクションは、Web アプリケーションの脆弱性を悪用して攻撃者が不正な SQL 文を注入し、データベースを不正に操作する攻撃手法

### 発生し得る被害

- データベース内のデータを不正に読み取り、機密情報を盗み出す
- データベースのデータを改ざんまたは削除する
- データベースの構造を把握し、システムに対するさらなる攻撃のための情報を収集する
- データベースサーバーを制御下に置く

### 対処法

- パラメータ化クエリ（プレースホルダ）

  - SQL 文の作成にはパラメータ化クエリ（またはプリペアドステートメント）を使用する
  - SQL 文とパラメータを分離し、SQL インジェクションを防止する

- 入力の検証とサニタイズ

  - ユーザからの入力はすべて信頼できないものと見なし、厳密なホワイトリスト方式で入力の検証を行う
  - また、入力値を SQL 文に直接組み込む場合は、必ずエスケープ処理を行う

- 最小権限の原則

  - データベースに対するアクセス権限は、必要最低限のものに制限する
  - 例えば、Web アプリケーションからデータベースにアクセスするアカウントは、必要なテーブルへの読み書きだけが可能な権限を持つようにする

- エラーメッセージの管理
  - データベースエラーの詳細をユーザーに表示しないようにする
  - これにより、攻撃者がエラーメッセージからシステム情報を収集するのを防ぐ

## CSRF (Cross-Site Request Forgery)

### 仕組み

- CSRF は、ウェブサイトの訪問者が悪意のあるサイトやメール等を介して罠にかけられ、自分の意図しないリクエストを送信してしまう脆弱性のこと
- 例えば、ユーザがログイン状態のサービス A を利用しているとする
- この時、罠のあるサイト B にアクセスすると、そのサイトからサービス A に対して何らかの操作（情報の更新や削除など）を行うリクエストが送信され、その操作が実行されてしまう
- これは、ウェブブラウザが送信するリクエストに自動的に Cookie が含まれ、その Cookie 内のセッション ID によってユーザが認証される仕組みを悪用している

### 発生し得る被害

- CSRF の攻撃を受けると、ユーザの知らない間にそのユーザの権限で行動が実行されてしまう可能性がある
- たとえば、SNS での投稿、EC サイトでの注文、パスワードやメールアドレスの変更、金融サービスでの送金など、ユーザの意図しないあらゆる操作が可能になる

### 対処法

- CSRF トークンの利用

  - フォーム送信時にサーバー側で生成したランダムな文字列（CSRF トークン）を用い、リクエストが本物であることを確認する
  - サーバー側では、フォームから送られてきたトークンとサーバー側で保持しているトークンが一致することを確認し、一致しなければそのリクエストは拒否する

- SameSite 属性の利用

  - 最近のブラウザでは、Cookie に SameSite 属性を設定することができる
  - Cookie が同一サイト内でのみ送信されるように制限することができる
  - 他のサイトからのリクエストが自動的に認証されることを防ぐ

- ダブルサブミットクッキー
  - サーバーがランダムな値をクッキーに設定し、その同じ値をフォーム内の隠しフィールドにも設定する
  - その後、サーバー側でクッキーとフォームの値を比較し、同一であることを確認する
  - これにより、ユーザーが操作を認証・承認したものだけがサーバーに到達することを保証する

## 正規表現エンジンに負荷がかからないか検討する理由

- 正規表現（RegEx）を使ったマッチング操作は、その正規表現がどのように書かれているかにより、計算量が著しく異なることがある
- 特に「キャタストロフィックバックトラック」などの現象が生じると、正規表現エンジンは指数関数的に増大する計算時間を必要とすることがある
- これは、主にバックトラッキングが多い正規表現（「.＊」のような広範なマッチングを行うパターン、または複数の可能性を含む正規表現）で起こる
- こうした正規表現を大量の文字列に対して実行すると、エンジンは全ての可能なマッチングを試みるため、大量の時間とメモリを消費する
- 極端な場合、これはサービス拒否（DoS）攻撃に繋がる可能性がある
- したがって、正規表現を用いる際には以下のことを検討することが重要
  - 正規表現は最小限に抑え、必要な部分だけをマッチング対象にする
  - 可能であれば、正規表現の代わりに文字列操作関数を使用する
  - 入力サイズを制限して、大きな文字列に対する正規表現の実行を防ぐ
  - パフォーマンスの悪い正規表現（「キャタストロフィックバックトラック」を引き起こす可能性のあるもの）の使用を避ける。

## 課題２（クイズ）

- Stored XSS と Reflected XSS の主な違いについて説明してください

## 課題 3: DVWA を使用したデモ

### コマンドインジェクション

通常: 127.0.0.1

```
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.845 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.151 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.161 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.142 ms
--- 127.0.0.1 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.142/0.325/0.845/0.300 ms
```

コマンドあり: 127.0.0.1 && dir

```
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.458 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.083 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.102 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.059 ms
--- 127.0.0.1 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.059/0.175/0.458/0.164 ms
help  index.php  source // ディレクトリの中身が見えてしまっている
```

### SQL インジェクション

SQL: 1' or 'a'='a

```
ID: 1' or 'a'='a
First name: admin
Surname: admin
ID: 1' or 'a'='a
First name: Gordon
Surname: Brown
ID: 1' or 'a'='a
First name: Hack
Surname: Me
ID: 1' or 'a'='a
First name: Pablo
Surname: Picasso
ID: 1' or 'a'='a
First name: Bob
Surname: Smith
```

### CSRF

下記の URL を踏むとパスワードが変わる
http://localhost/vulnerabilities/csrf/?password_new=password&password_conf=password&Change=Change

### XSS

下記の URK を踏むとアラートを表示することができる
http://localhost/vulnerabilities/xss_d/?default=English%3Cscript%3Ealert(1)%3C/script%3E

# 課題 4 OWASP Top Ten を読む

https://cheatsheetseries.owasp.org/IndexTopTen.html

## 壊れたアクセス制御に対して

- Amazon CloudFront でアクセス制御をしている
- CORS の設定は実施している
- 認可されていないユーザーが API 単位でアクセスできないようになっている
- コード上で権限に応じたビジネスロジックが実装されているが、ドメインオブジェクトにはなっていない
- アクセス制御の失敗をログに記録している
- セッション ID はログイン後に発行され、ログアウト後には無効化される
