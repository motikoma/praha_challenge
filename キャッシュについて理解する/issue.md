# 課題 1（質問）

## キャッシュとは

キャッシュは、頻繁にアクセスするデータや再利用可能な結果を一時的に保存するための領域であり、その主な目的はパフォーマンスの向上と効率性

## キャッシュヒット率とは

- キャッシュヒット率は、キャッシュの効率性を示す指標の一つで、キャッシュからデータを正常に取得できるリクエストの割合
- 具体的には、全てのキャッシュリクエストに対してキャッシュヒット（キャッシュからデータが見つかった場合）がどれだけの頻度で発生しているかをパーセンテージで表したもの
- キャッシュヒット率 = (キャッシュヒットの数 / 全キャッシュリクエストの数) \* 100
- キャッシュヒット率を向上させるための一般的な戦略
  - キャッシュポリシーの最適化: どのデータをキャッシュに保存し、どのくらいの期間保存するかを決めるキャッシュポリシーを見直す
  - キャッシュサイズの調整:キャッシュのサイズが小さいと、頻繁にデータが排除されてキャッシュミスが増える可能性がある。一方、キャッシュのサイズが大きすぎると、使用されていないデータがキャッシュに残り、リソースの無駄になる可能性がある
  - 適切なキャッシュ置き換えアルゴリズムの選択: 新たなデータをキャッシュに加えるためには、既存のデータを排除するアルゴリズムにはいろいろある
  - キャッシュの階層化: よく使うデータは高速なキャッシュに、あまり使わないデータは大きなキャッシュに配置する

## キャッシュには様々な種類がある。いくつか例を挙げてそれぞれのキャッシュの違いを

### ブラウザキャッシュ

- ブラウザキャッシュはウェブブラウザがローカルに保存するキャッシュ
- HTML、CSS、JavaScript、画像などの静的リソースは、ユーザがウェブサイトを訪れるたびにダウンロードする必要があるが、これらのリソースは頻繁に変更されるものではないため、ブラウザはこれらのリソースをローカルのディスクにキャッシュする
- ユーザが再度同じウェブサイトを訪れると、ブラウザはキャッシュからこれらのリソースを取得することで、ページの読み込み速度を大幅に向上させることができる

### プロキシキャッシュ

- プロキシキャッシュは、ネットワークのゲートウェイ（つまり、ネットワークの入出口）に設置され、ネットワークを通過するすべての HTTP リクエストとレスポンスをキャッシュする
- これにより、同じリクエストが再度発生したときには、プロキシが直接レスポンスを提供できる
- ネットワークの帯域幅の使用を減らし、レスポンス時間を短縮することができる
- これは特に、大規模な企業ネットワークや ISP(Internet Service Provider)で有効

### CDN キャッシュ：CDN(Content Delivery Network)は

- 地理的に分散したサーバーネットワークで、ユーザに近い場所にコンテンツを提供することでウェブサイトのパフォーマンスを向上させる
- CDN は、各地に配置されたエッジサーバーに静的コンテンツをキャッシュし、ユーザのリクエストに応じてこれらのキャッシュからコンテンツを提供する
- これにより、ネットワーク遅延を軽減し、ウェブサイトの応答時間を改善することができる

### データベースキャッシュ

- データベースキャッシュは、データベースクエリの結果を保存するために使用される
- データベース操作は通常、リソースを大量に消費し、遅延が発生する可能性がある
- したがって、頻繁に使用されるクエリの結果をキャッシュに保存しておくことで、同じクエリが再度実行されるときにはデータベースへのアクセスを避けることができ、アプリケーションのパフォーマンスを大幅に向上させることができる
- 一般的には、Memcached や Redis のようなインメモリデータストアがこの目的で使用される

### ハードウェアキャッシュ

- 物理的なハードウェアレベルでのキャッシュで、CPU キャッシュ（L1、L2、L3 キャッシュなど）やディスクキャッシュ（ハードドライブや SSD がデータを一時的に保存する領域）などがこれに該当する
- これらのキャッシュは、それぞれのハードウェアがより効率的に動作するようにするために存在する
- 例えば、CPU キャッシュは、CPU が次に必要とするデータを予測してそのデータを一時的に保存し、CPU がメインメモリから直接データを取得するよりもはるかに高速にデータを提供できる

## HTTP 通信における、ブラウザがキャッシュを制御するために存在するヘッダーを 3 つ以上挙げて、それぞれの役割を説明してください

### Cache-Control

- HTTP/1.1 で導入されたヘッダーで、キャッシュをどのように制御するかを指定する
- Cache-Control ヘッダーにはいくつかのディレクティブがあり、それぞれがブラウザやキャッシュサーバーに対して特定のキャッシュ動作を指示する
- 例えば、"no-cache"はキャッシュされたレスポンスを使用する前に、オリジンサーバーでその有効性を検証することを要求する
- 一方、"max-age"はリソースが新鮮であると考えられる最大時間を指定する

### Expires

- HTTP/1.0 で導入されたヘッダーで、レスポンスがいつ古くなるか（つまり、もはや新鮮でないと考えられるか）を示す日付/時刻を提供する
- Expires ヘッダーに指定された時間が過ぎると、キャッシュはそのレスポンスを新鮮でないと考え、新たなリクエストを行うか（Cache-Control ヘッダーの指示に従って）有効性の再検証を行う

### Pragma

- Pragma は HTTP/1.0 のヘッダーであり、HTTP レスポンスに特定されないため HTTP/1.1 の Cache-Control 一般ヘッダーを確実に置き換えるものではない
- しかし、リクエストで Cache-Control ヘッダーフィールドが省略された場合は Cache-Control: no-cache と同様に作用する
- HTTP/1.0 クライアントとの後方互換用に限り、Pragma を使用する

## ブラウザのキャッシュサイズの容量上限を超えると何が起きるか

- 各ブラウザーは、あるオリジンで使用できるキャッシュストレージの総量に厳しい制限を設けている
  - Firefox ではユーザーのプロファイルが保存される合計ディスク サイズの 10% または 10Gib
- Cache 容量の概算の使用量は StorageManager.estimate() API を用いて確認することができる
- ブラウザーはディスク容量の管理に最善を尽くすが、最近使用されていないオリジンのキャッシュストレージを削除することがある

参考：https://developer.mozilla.org/ja/docs/Web/API/Cache
参考：https://developer.mozilla.org/en-US/docs/Web/API/Storage_API/Storage_quotas_and_eviction_criteria

## 動的なサイトでは expires は使わない理由

- 「Expires」ヘッダは HTTP 応答の一部であり、ブラウザがキャッシュされたリソースを再利用できる期間を示す
- 「Expires」ヘッダは絶対時間を指定するため、特定の日付と時刻が過ぎると、ブラウザはキャッシュを無効とみなし、新しいリクエストをサーバに送信する
- しかし、動的なサイトではコンテンツが頻繁に変更されるため、事前に定められた期限が来る前に内容が更新される可能性がある
- その結果、ユーザは更新された情報を見逃し、古い情報を見てしまう可能性がある
- また、「Expires」ヘッダを使用すると、サーバーとクライアントの間で時間のズレが生じることがある
- たとえば、サーバーとクライアントの時計が正確に同期していない場合、クライアントは期限切れと誤認するか、または期限切れであるにもかかわらずキャッシュを再利用する可能性がある
- より新しいプロトコルである「Cache-Control」ヘッダが主に使用するべき。「Cache-Control」ヘッダを使用すると、キャッシュの挙動をより細かく制御できる
- 例えば、「max-age」ディレクティブを使用すると、リソースが古くなるまでの相対時間を指定できる。
- また、「no-cache」ディレクティブを使用すると、ブラウザはキャッシュを再利用する前に、サーバにリソースが変更されていないかを確認する必要がある

## ブラウザのキャッシュが WEB サービスに用いられている実例を、3 つ以上見つけて共有してください。どのような仕組みで対象がキャッシュされているのか、技術的な流れを説明してみてください

### docker.com

- CDN が使用されている
- public: このディレクティブは、このリソースが共有キャッシュ（CDN など）に保存され、複数のユーザーに対して使用されることを許可する。これは、デフォルトで非公開（private）に設定されているリソースに対して特に有用
- max-age=86400: このディレクティブは、リソースがどの程度の時間、キャッシュとして有効であるべきかを指定する。この場合、86400 秒（つまり 24 時間）です。この時間が経過すると、ブラウザはキャッシュされたリソースのコピーを使用する前に、元のサーバーに再確認を行う必要がある

### https://dena.com/jp/

- Adobe の Typekit サービスを利用しており、ウェブフォントがキャッシュされている
- public, max-age=31536000 という設定されており、ブラウザがそのリソースを 1 年間キャッシュすることを許可する

### https://vercel.com/

- https://vercel.com/status-api に対して、Cache-Control:public, max-age=0, must-revalidate が設定されている
- このリソースはキャッシュできますが、それを使用する前に常にオリジンサーバーで新鮮さを確認してくださいという指示をしている

# 課題２（実装）

- app 参照

# 課題３（成果物に関する質問）

- オンライン銀行のウェブサイトを想定
- ユーザーがログイン後に見るアカウントのダッシュボードページは、ブラウザキャッシュを使わない方が良い
  - ユーザーの最新の銀行口座の情報（残高、最近の取引など）を表示するため、常に最新の状態を反映していることが重要であるから
- セキュリティ観点でユーザーの個人情報を含むページをキャッシュすることは避けるべき
  - ブラウザのキャッシュは、他の人が同じデバイスを使用するときに、その情報を見ることが可能になる可能性があるから

# 課題４（クイズ）

- 陳腐化したリソースへのリクエストをキャッシュが受け取ると、実際はもう新鮮ではないかを確認するために If-None-Match を付加してリクエストを転送します。
- 新鮮な状態であればサーバーはどのような処理を行いますか？
