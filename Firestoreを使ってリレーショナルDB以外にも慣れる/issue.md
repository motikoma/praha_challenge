# 課題 1（モデリングと初期データ投入）

```
questions //課題のマスター
    - id: string
    - title: string
    - detail: string

users //ユーザー
    - id: string
    - name: string
    - questions: //サブコレクション
        - id: string //questionsコレクションのid
        - status: string
```

# 課題 2(実装)

## 特定のユーザーに紐づいた課題を「未完了」から「完了」状態に変更するスクリプト

- markQuestionsAsCompleted メソッド参照

## ユーザの課題ステータスを一覧表示するスクリプト

- showUserQuestions メソッド参照

## 特定の課題を更新するスクリプト

- updateQuestion メソッド参照

## 特定の課題を削除するスクリプト

- deleteQuestion メソッド参照

# 課題 2（質問）

## NoSQL における正規化について

- NoSQL の場合は具体的なユースケースを考えてそれに合致するデータ構造を考える必要がある
- 今回は同一内容の課題を複数のユーザーが回答することを想定しているので、課題のマスターとユーザーの課題進捗を別々のコレクションに分けている
- またコレクション単位でセキュリティルールを設定するため考慮する必要がある

## RDB と NoSQL の比較

### RDBMS

#### メリット

- 構造化されたデータ: RDBMS は、データを表形式で保存するため、構造化されたクエリ言語（SQL）を使用できる
- トランザクションの一貫性: ACID プロパティ（Atomicity, Consistency, Isolation, Durability）をサポートしているため、堅牢なトランザクション管理が可能
- データ整合性: スキーマ定義により、データ型や関連性の強制が可能で、データの整合性を維持できる

#### デメリット

- スケーラビリティ: 垂直スケーリングが主であり、水平スケーリングは複雑な場合が多い
- 柔軟性の欠如: 事前に定義されたスキーマに沿ってデータを格納する必要があるため、非構造化データや頻繁に変化するデータに対しては不便

### NoSQL

#### メリット

- スケーラビリティ: 多くの NoSQL データベースは水平スケーリングをサポートしており、大量のデータとトラフィックを処理できる。
- 柔軟性: スキーマレスであるため、構造化、半構造化、非構造化データを柔軟に扱える。
- 高速な読み書き: 用途に応じたデータモデル（キー値、ドキュメント、グラフなど）により、特定の操作で高いパフォーマンスを提供する。
- ビッグデータ対応: 高い並列処理能力を持つため、ビッグデータの分析に適している。

#### デメリット

- トランザクションの一貫性: ACID プロパティのサポートが限られているか、存在しない場合があるため、一貫性を要求するトランザクションには向いていない
- 複雑なクエリ: クエリの複雑さや機能に制限がある場合がある
- データ整合性: スキーマレスであるため、データの整合性を保つことが難しい

# 参考情報

- [NoSQL データモデリング技法](https://gist.github.com/matope/2396234#3%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B5%E3%82%A4%E3%83%89join-application-side-join)
- [Firebase 公式動画から『Firestore の DB 設計の基礎』を学ぶ](https://qiita.com/KosukeSaigusa/items/860b5a2a6a02331d07cb#%E3%81%8A%E6%B0%97%E3%81%AB%E5%85%A5%E3%82%8A%E3%81%AE%E3%83%AC%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3%E3%82%92%E4%BF%9D%E5%AD%98%E3%81%99%E3%82%8B)
- [【Firebase】Firestore(NoSQL)でのデータベース設計の基本 と RDB との設計方法の違い について](https://flutter-square.com/firestore-nosql-basic-design/)
