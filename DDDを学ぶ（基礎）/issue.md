# DDDを学ぶ（基礎）
## 課題1
エンティティ
* 同一判定を識別子で行う
* 例：社員エンティティ。識別子は社員番号

値オブジェクト（バリューオブジェクト）
* 同一判定を保持する値で行う
* 不変
* 例：10円玉

集約
* 必ず守りたい強い整合性を持ったオブジェクトのまとまり
* 集約ごとに親となるオブジェクトを決めて、集約ルートと呼ぶ
* 整合性を確保するためにトランザクションを必ず1つにする
    * 必ず集約単位でリポジトリから取得し、集約単位でリポジトリに渡す
* 集約の中の一部オブジェクトのみの取得/更新は許可しない
    * 目的は、集約内のオブジェクトの整合性が崩れるのを防ぐため
    * 例：部と部員を同時に取得し、部員に対する操作は必ず部オブジェクトを経由させるようにする。部オブジェクトに部と部員を合わせた状態管理の責務を持たせ、部員を外部から直接操作できないようにする。

ユビキタス言語
* 全員で同じ言葉でコミュニケーションを行うための共通言語
* 境界づけられたコンテキスト内でのみ使われる言葉を定義する

境界づけられたコンテキスト
* 特定のモデルを定義・適用する境界を明示的に示したもの
* 例：サブシステムやチーム

ドメイン
* ソフトウェアで問題解決しようとする対象領域
* 参考：Domain-Language.comの「DDD Reference」の定義


ドメインサービス
* モデルをオブジェクトとして表現すると無理があるもの
* 極力エンティティとバリューオブジェクトで実装するようにして、どうしても避けられない場合のみ使用する
* 「サービス」という文言をクラス名につけがちだが、責務が不明確になるので非推奨で、責務にあった名称をつけると良い
* 例：集合に対する操作,ファクトリー
* 例：メールアドレスの重複チェック

リポジトリ
* 集約単位で永続化層へのアクセスを提供する
* リポジトリが集約の範囲をコードで表現する唯一のものなのでドメイン層に定義する
* ユースケース層にリポジトリを定義してしまうと集約の範囲に関する情報がドメイン層になくなる
    * ユースケース層で 1 つのエンティティに対して複数リポジトリが作られ、それらが定義する集約の範囲が異なっていても、ドメイン層としては検知できなくなってしまう

アプリケーション（ユースケース層と呼ばれることも）
* ドメイン層が公開している操作を組み合わせてユースケースを実現する
* 具体的には、ドメインオブジェクトの生成や状態の変更、リポジトリを使用した永続化など
* 特定のクライアントには依存しない実装にする
* ユースケース層に認証情報を表すインターフェイスを定義し、その実装クラスをプレゼンテーション層に定義する

CQS/CQRS（似ているため、違いを重点的に調べてみましょう）
* CQS（Command Query Separation）
    - BertrandMeyerが述べた設計の原則
    - 簡単に説明すると、メソッドは、コマンドまたはクエリーのいずれかであり、両方にすべきではない、ということです。
    - コマンドとは、オブジェクトの状態を変更できるものの、値を返さないメソッド
    - クエリーは、値は返すものの、オブジェクトの状態を変更しないメソッド
    - 最も重要なことは理解しやすさ。メソッドがクエリーだとわかれば、副作用を起こさずに何度も続けて呼び出せるかどうかを、メソッドの中身を見て判断する必要がない
* CQRS（Command Query Responsibility Segregation）
    - 「情報の参照に使用するモデルと更新に使用するモデルに異なるものを使用する」というアーキテクチャパターン
    - 
* 両者の違い
    - CQSはオブジェクト単位でメソッドの責務を更新と取得に応じて明確に分離すること
    - CQRSはそれをアーキテクチャレベルに適用したもの。ただ、データソースの分離を行うか〜など分離レベルに関する定義は様々存在した

DTO
* データ転送オブジェクト
* 可変。外から変更可能（getter,setter）
* 異なるレイヤー間（モデル層、ビュー層など）でデータを受け渡すのに使う

ドメインモデル貧血症
* データをもつクラスを作りながらも、フィールドのGetter/Setterだけをもつクラスを作ってしまうこと
* ドメインオブジェクトに業務知識が実装されず、それを使う側に任されることになる

### 参考文献
* [10分DDD](https://little-hand-s.notion.site/10-DDD-16b44b0b3e1e4aa2a67659b2085e0c6b?p=96aaf637cc9a4139aee9fc3e69ee32e8&pm=s)

## 課題2
### 境界づけられたコンテキストの実例
「在庫管理コンテキスト」における仕入の発注金額と「注文コンテキスト」の商品価格としての金額は異なる
### Humanエンティティ
src/Human.tsを参照
### なぜ値オブジェクトにするべきなのか？
例えば血液型に関しては、A型,B型,O型など格納されるデータが決まっている。バリューオブジェクトにすることで、バリデーションを内部に閉じ込めることができる。バリューオブジェクトにしない場合、エンティティを使用する複数のユースケースでバリデーションが書き散らされることになり、ビジネスロジックが分散してしまう。
### Humanエンティティの各プロパティを値オブジェクトにした場合
src/Human2.tsを参照

## 課題3
### ドメイン知識が漏れている場合のサンプル
src/Human3.tsを参照

## 課題4
DDDとクリーンアーキテクチャの違いについて調べてみてください