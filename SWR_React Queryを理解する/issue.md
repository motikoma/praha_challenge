# 課題 1

## SWR が生まれた背景

### 概要

- SWR は、まずキャッシュからデータを返し（stale）、次にフェッチリクエストを送り（revalidate）、最後に最新のデータを持ってくる

### 課題意識

- プロジェクト内のデータ取得のロジックが複雑
  - 通常、すべてのデータをトップレベルのコンポーネントに保持し、ツリーの奥深くにあるすべてのコンポーネントに props を追加する必要がある
  - ページにデータの依存関係を追加すると、コードの保守が難しくなります。
  - Context を使って props を渡すことは避けられますが、動的なコンテンツの問題は残る
  - ページコンテンツ内のコンポーネントは動的に変化する可能性があり、トップレベルのコンポーネントは、子コンポーネントがどのようなデータが必要かを知らないかもしれない

### 解決策

たった 1 行のコードで、プロジェクト内のデータ取得のロジックを単純化し、さらにこれらの素晴らしい機能をすぐに利用できるようになる

- 速い、 軽量 そして 再利用可能 なデータの取得
- 組み込みの キャッシュ とリクエストの重複排除
- リアルタイム な体験
- トランスポートとプロトコルにとらわれない
- SSR / ISR / SSG support
- TypeScript 対応
- React Native

SWR は、スピード、正確性、安定性のすべての面をカバーし、より良い体験を構築するのに役立つ

- 高速なページナビゲーション
- 定期的にポーリングする
- データの依存関係
- フォーカス時の再検証
- ネットワーク回復時の再検証
- ローカルキャッシュの更新（Optimistic UI）
- スマートなエラーの再試行
- ページネーションとスクロールポジションの回復
- React Suspense

## React Query が生まれた背景

### 概要

- Web アプリケーションのサーバー状態の取得、キャッシュ、同期、更新を容易にする

### 課題意識

- Web フレームワークにはデータを取得,更新するための方法が用意されていない
- 現状は状態管理ライブラリを利用していて、コンポーネントに状態と副作用を組み合わせることで、データの取得,更新を行う
- 従来の状態管理ライブラリの多くは、クライアントの状態を扱うのには適していますが、非同期やサーバーの状態を扱うのはあまり得意ではありません。これは、サーバーの状態が全く異なるため
- サーバーの状態には以下のような特徴がある
  - 管理も所有もしない場所に永続化される
  - 取得と更新のために非同期 API を必要とする
  - 所有権の共有を意味し、あなたの知らないところで他の人が変更する可能性がある
  - 気をつけないと、アプリケーションの中で「古くなる」可能性がある
- アプリケーションにおけるサーバーの状態の本質を把握すれば、さらに多くの課題がどんどん出てくる
  - キャッシュ...（プログラミングの中で一番難しいかもしれない）
  - 同じデータに対する複数のリクエストを、1 つのリクエストに分割する。
  - バックグラウンドで「古くなった」データを更新する。
  - データが "古くなった "ことを把握する
  - データの更新をできるだけ早く反映させる
  - ページネーションやデータの遅延読み込みなど、パフォーマンスの最適化
  - サーバー状態のメモリとガベージコレクションの管理
  - 構造的な共有によるクエリ結果のメモ化

### 解決策

- React Query は、上記のような複雑な課題を解決するためにサーバーの状態を管理するためのライブラリの 1 つ
- 初期設定なしで、アプリケーションの成長に合わせて好みに合わせてカスタマイズすることができる
  - アプリケーションから複雑で誤解されやすいコードを削除し、わずか数行の React Query ロジックに置き換えることができる
  - アプリケーションの保守性を高め、新機能の構築を容易にする
  - アプリケーションをこれまで以上に高速化し、応答性を高める
  - 帯域幅の節約とメモリ性能の向上が期待できる

## 「必要なデータを一箇所で取得してから props でコンポーネントに渡して行った方がシンプルでは？」に対する回答

- トップレベルのコンポーネントが子コンポーネントの事情を知る必要があるという意味で複雑さが増していく
- 子コンポーネントが自分自身で必要なデータを取得できれば、トップレベルのコンポーネントは子コンポーネントの事情を知る必要がなくなる
- また、コンポーネント間でデータを共有する処理が抽象化されるため、シンプルになる

## 「SWR とか React Query を使うと、描画のタイミングでデータ取得が始まってしまうからコンポーネント単位でテストしづらくなりませんか？」に対する回答

適切なツールを使用すれば、React Query や SWR を使用してもコンポーネント単位のテストは可能

- データフェッチングを行うフックやライブラリ関数をモック化（模擬実装）したり、スタブ（代用品）を使用することで、テスト中に実際のデータフェッチングを行わないようにすることができる。これにより、テストは高速になり、外部依存性から独立した状態で実行できる
- React Query と SWR は、テスト中にデータフェッチを模擬するためのユーティリティを提供している。例えば、React Query では Hydrate と Dehydrate を使ってサーバーサイドレンダリングのテストを行ったり、setQueryData を使って特定のクエリデータを手動でセットしたりできる。

## 「SWR を使ってデータの取得と描画に関する責務を一つのコンポーネントにまとめてしまうのは SRP（単一責任原則）に違反している気がします」に対する回答

- React コンポーネントと SWR（または React Query）を組み合わせるとき、単一責任原則をどのように解釈するかは、責任とは何か、つまり「一つのこと」とは何かによる
- 一つのコンポーネントがデータの取得とそのデータの表示を行うとき、それは「データを取得して表示する」という一つの責任を果たしているとも解釈できる。
- また、データ取得の詳細は SWR や React Query に委譲され、コンポーネント自体は主に表示のロジックに集中できるとも言える
- したがって、「SWR を使ってデータの取得と描画に関する責務を一つのコンポーネントにまとめる」ことが必ずしも SRP に違反するとは限らないと言える
- ただし、コンポーネントが大きく複雑になってきた場合、データ取得と描画を別のコンポーネントやカスタムフックに分割することで、よりクリーンで再利用可能なコードを書くことが可能

# 課題 2

https://codesandbox.io/s/react-typescript-forked-56cp8x?file=/src/App.tsx

# 課題 3

- swr で実装を試みる
- TanStack Query v4 と Storybook v7 の相性が悪く、Provider を設定しても型を参照するエラーが出て断念した
  参考:https://dev-yakuza.posstree.com/react/nextjs/storybook/v7/start/
