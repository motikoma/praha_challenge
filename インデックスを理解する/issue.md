# 課題 1（質問）

## インデックスの仕組み

- インデックスとは、データベースの中にあるデータの位置を特定するために使用される機能。データベースは膨大な量のデータを格納することができるが、これらのデータを検索するには時間がかる。インデックスを使用することで、データベースは効率的にデータを検索できるようになる。
- 例えば、電話帳には、人々の名前と電話番号が記載されてる。あなたが友達の電話番号を知りたい場合、電話帳全体を手動で探すことがで切るが、これは非常に時間がかかる作業。しかし、電話帳がアルファベット順に並べられている場合、友達の名前の最初の文字から検索を始めることができる。このように、アルファベット順に並べた電話帳は、検索がはるかに簡単になる。
- データベースでも同様に、インデックスはデータを特定の順序で格納することによって、検索を高速化することができる。たとえば、あるデータベースにおいて、顧客の情報を氏名順に格納する場合、インデックスを使用することで、顧客の氏名をキーにして、すばやく顧客の情報を検索することができる。
- ただし、インデックスを使用する場合には、データベースの更新処理やデータの追加に多少のコストがかかることがある。これは、インデックスを更新する必要があるため。

## インデックスを貼る際に slow query log を調べる必要がある理由

- インデックスを貼る際に slow query log を調べる必要がある理由は、インデックスを貼ることでクエリのパフォーマンスが向上する場合もあれば、逆にパフォーマンスが悪化する場合もあるため
- インデックスを使って検索することで、データベースがテーブル全体をスキャンする必要がなくなり、クエリの実行時間が短縮される場合がある。しかし、インデックスが適切に設定されていない場合、クエリの実行時間がむしろ長くなってしまう場合がある。例えばクエリに使用されないカラムにインデックスが貼られていた場合、余分なデータを読み込んでしまう。
- slow query log は、クエリの実行時間が長い場合にログを出力する機能であり、インデックスを貼る前と貼った後で実行時間がどのように変化したかを確認するために利用される。slow query log を調べることで、インデックスの設定方法を適切に調整し、クエリのパフォーマンスを改善することができる。
- インデックスを作成すると、INSERT、UPDATE、DELETE の際にインデックスを変更するコストが増える

## カーディナリティとは

- カーディナリティとは、あるカラムに含まれるユニークな値の数のこと
- あるカラムに重複した値が多く含まれている場合、カーディナリティは低くなる。

## カバリングインデックスとは

- カバリングインデックス（Covering Index）は、インデックスを使ってクエリの結果を返す際、実際のデータを参照する必要がないようにするための仕組み
- 通常、クエリによるデータの検索は、まずインデックスを使って該当する行を見つけ、その行の実際のデータを参照して、必要な情報を取得することで行われる
- しかし、カバリングインデックスを使用すると、インデックスに必要な情報が全て含まれているため、実際のデータを参照する必要がなくなる
- つまり、カバリングインデックスを使用することで、データベースはインデックスだけを参照してクエリの結果を返すことができ、データベースへのアクセス回数を減らすことができる。
- これにより、クエリの処理速度を大幅に高速化することができる
- ただし、カバリングインデックスを使用するためには、インデックスに必要な情報が全て含まれている必要がある。
- また、不要なメモリを確保したり、update 文実行時のメンテナンス コストが増えたりするため、実際には where 句などを優先し、select 句を考えずにインデックスを作って、必要があればそこから拡張していくべき

## autoincrement の id カラムを PK として扱う上ではどのようなメリット・デメリット

- 【メリット】
  - ID カラムを自動生成することで、一意の識別子を簡単に取得することができる
- 【デメリット】
  - サービスが統合される必要が出てきた場合など、ID が重複する可能性がある
  - URL に ID を含める場合、ID が連番だと推測されやすくなる
  - 永続化しないと ID が生成されないため、ドメイン駆動設計の場合アプリケーション上で ID が null の状態でインスタンスを作成する必要が出てくる
  - レコードを物理削除して、末端のレコードを出した場合、MySQL を再起動すると AUTO INCREMENT 値が残ってる最後の INCREMENT 値に変わる。関連テーブルにレコードが残っていると新規レコードができた場合に同じ ID がふられて、残っている関連テーブルのレコードが紐づく事になるというバグを生み出してしまう
    　- https://www.bravesoft.co.jp/blog/archives/10517

# 課題 2（実装）
