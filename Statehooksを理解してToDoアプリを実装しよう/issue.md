# 課題 1

## フックを使うことのメリット

関数コンポーネントの再利用性向上

- Hooks は関数コンポーネントの再利用性を向上させます。カスタムフックを作成することで、複数のコンポーネント間でロジックを共有することができます。

コードのシンプルさと読みやすさ

- Hooks を使用すると、クラスコンポーネントに比べて、コードがシンプルになり、読みやすくなります。
- フックを利用することで、ライフサイクルメソッドの場合は分離して書かざるを得なかったコンポーネント内の副作用を、関連する部分（リソースの購読とその解除、など）同士で整理して記載することが可能になる。

## 実践で使えそうなカスタムフックの紹介

https://github.com/streamich/react-use/blob/master/docs/usePromise.md

- コンポーネントのマウントが完了してから非同期処理が実行される
- コンポーネントのマウントが完了せずにアンマウントされた場合、非同期処理がキャンセルされる

### 便利な理由

- このカスタムフックを使うことで、非同期処理が実行されるのはコンポーネントのマウントが完了してからなので、React の警告が発生することはない
- メモリリークや意図せぬ state の上書きを防ぐことができる

# 課題 2

## TODO アプリのリファクタリング

https://codesandbox.io/s/determined-bas-isbimg?file=/src/TodoBox.tsx

### immer が開発された背景

- イミュータブルであるべきだが、前の状態から新しい状態を生成することは退屈で定型的な作業でめんどくさい

# 課題 3

## 「Container」と「Presentational」は、React コンポーネントを役割や責務に基づいて分割するための設計パターン

https://zenn.dev/buyselltech/articles/9460c75b7cd8d1

- Container Component
  - データの取得や更新、状態の管理などのロジックを担当するコンポーネント
  - ロジックを担当するため、コンポーネントを跨いだ状態を持つ
- Presentational Component
  - ロジックを持たず、UI のみを担当するコンポーネント
  - コンポーネント内で完結する UI に関する local な状態を持つことが可能
  - ロジックを持たないため、コンポーネントを跨いだ状態を持たない

## 両者を分けることによって、以下のようなメリットがある

- コードの可読性や保守性が向上
- Presentational コンポーネントは再利用可能になる
- Presentational コンポーネントは状態やロジックを持たず、props を受け取って表示を行うだけなので、テストが容易になる

## AtomicDesign に Container コンポーネントを適用

Pages に相当するコンポーネントが Container として該当するので、下記が該当する

- 適切にコンポーネントを分割して 1 ページ作ってみよう/my-app/pages/commerce.tsx

## Controlled Component と Uncontrolled Component の違い

「controlled」と「uncontrolled」は、React コンポーネントの状態管理のアプローチを表す用語

### 「Controlled Components（制御されたコンポーネント）」

- コンポーネントの状態を外部から完全に制御するアプローチ
- コンポーネントの状態は外部で管理され、コンポーネントは外部から提供されたプロパティ（props）を介して状態を更新する
- 制御されたコンポーネントでは、コンポーネント自体は内部的に状態を持たず、外部で状態を管理するため、コンポーネントの振る舞いを完全に制御することができる
- 制御されたコンポーネントのメリット
  - 状態が外部で一元管理されるため、データの流れが明確で予測可能
  - コンポーネントの状態をテストしやすく、予測可能な結果を得ることができる
  - フォームやユーザー入力のような動的なデータの管理に適している
- 制御されたコンポーネントのデメリット
  - 状態管理のために追加のコードやプロパティの設定が必要
  - コンポーネント内に状態を持たないため、コンポーネントが複雑になる可能性がある

### 「Uncontrolled Components（非制御コンポーネント）」

- コンポーネント自体が状態を持ち、内部的に状態を管理する
- ユーザーの入力やイベントによってコンポーネントの状態が変化し、コンポーネント自身が状態を更新する
- 例：非制御コンポーネントを記述するには、各 state の更新に対してイベントハンドラを書く代わりに、ref を使用して DOM からフォームの値を取得する
- 非制御コンポーネントのメリット
  - 状態管理のための追加のコードやプロパティの設定が不要
  - 簡潔なコードでコンポーネントを記述できる
  - 単純な操作や状態管理が不要な場合に適している
- 非制御コンポーネントのデメリット
  - 状態がコンポーネント内に閉じているため、外部から状態を制御することが難しくなる
  - 状態の変更を追跡するためのカスタムロジックが必要になる場合がある

## 参考情報

https://ja.legacy.reactjs.org/docs/forms.html#controlled-components
https://ja.legacy.reactjs.org/docs/uncontrolled-components.html#gatsby-focus-wrapper
https://zenn.dev/takepepe/articles/universal-framework-atoms

# 課題 4

## useState に関するクイズ

useState フックを使用するときに注意すべき点について教えてください
