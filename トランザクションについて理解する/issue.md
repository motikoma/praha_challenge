# トランザクションについて理解する

## 課題 1（質問）

### デッドロックとは

- デッドロックは、複数のトランザクションが同時にデータベースのリソースにアクセスし、それらのトランザクションが相互に依存している場合に発生する問題です。具体的には、一方のトランザクションが利用中のリソースを別のトランザクションが同時に利用しようとした場合、データベースはそのリソースをどちらかに割り当てる必要があります。しかし、どちらのトランザクションも相手のリソースを解放せずに待機しているため、リソースを割り当てることができずに処理が停止してしまう状態に陥ります。
- 例えば、高校生が 2 つの友達と一緒に夏休みの宿題をやっていると想像してみましょう。3 人が同じテーブルに座っており、1 人が計算問題を解いている最中に、別の 1 人がその人が利用中の計算機を使いたいと要求しました。しかし、最初の人が計算問題を解決するまでその計算機を使い続ける必要があるため、計算問題を解決する前に計算機を解放することはできません。同時に、最初の人も計算機を解放できないため、2 人はお互いに計算機を使えなくなってしまいます。これがデッドロックの一例です。
- データベースにおけるデッドロックも同様に、トランザクションが同じデータを更新しようとしている場合や、異なる順序でリソースを取得しようとしている場合に発生することがあります。デッドロックが発生すると、処理が停止してしまい、他のトランザクションの実行も停止してしまうため、データベースのパフォーマンスが低下する原因となります。

### 実際の事例

- メルカリの事例: https://engineering.mercari.com/blog/entry/2017-12-18-deadlock/
- 1 トランザクションで出品者の情報を更新し、購入者の情報を更新するケース
- 下記のパターンが同時に発生するとデッドロックになる
  - A さんが出品者、B さんが購入者
  - B さんが出品者、A さんが購入者
- デッドロックの解消には id などの絶対値で sort して、書き込み順を揃える
  - 同時アクセスがあっても必ず id が小さい方のレコードからロックを取るため、ロックを取れなかった方はロックが取れるまで他の行のロックを取ろうとすることはない

### ISOLATION LEVEL（分離レベル） とは

https://gyazo.com/c4a4e46fb3d2b1dd949c7cc629b6af00

- READ UNCOMMITTED

  - 確定していないデータも読み取る。
  - 問題点: ダーティリード（Dirty Read）。他のトランザクションによって更新されたがまだコミットされていないデータを読み取り、誤った結果を返す可能性がある

- READ COMMITTED

  - 確定した（コミット済）最新データを常に読み取る
  - 問題点: ノンリピータブルリード（Non-Repeatable Read）。同じクエリを実行したときに、異なる結果が返される可能性がある。このレベルでは、他のトランザクションによって更新されたデータがコミットされた場合、同じクエリを実行したときに異なる結果が返される

- REPEATABLE READ

  - 読み取り対象（他のトランザクションで変更されることはない）のデータを常に読み取る
  - 問題点: ファントムリード（Phantom Read）。同じクエリを実行したときに、異なる数の行が返される可能性がある。このレベルでは、他のトランザクションによって新しいデータが追加された場合、同じクエリを実行したときに異なる数の行が返される。

- SERIALIZABLE
  - トランザクションが直列化された場合と同じように処理される。
  - 問題点: ロック競合によるタイムアウト。このレベルでは、トランザクションのロック競合が頻繁に発生する可能性があり、結果としてトランザクションのタイムアウトが発生する場合がある。

### 行レベルのロック、テーブルレベルのロックの違い

行レベルのロックとテーブルレベルのロックの違いについては以下のような点が挙げられる

- ロックの範囲
  - 行レベルのロック: 行ごとにロックがかかる
  - テーブルレベルのロック: テーブル全体にロックがかかる
- ロックの粒度
  - 行レベルのロック: ロックがかかっている行に対する操作以外は自由に行える
  - テーブルレベルのロック: ロックがかかっているテーブルに対するすべての操作がブロックされる
- ロック競合の頻度
  - 行レベルのロック: 複数のトランザクションが同時に同じ行を更新しようとすると、ロック競合が発生する可能性がある
  - テーブルレベルのロック: 他のトランザクションがテーブルに対して操作を行うことができないため、ロック競合が発生することはない。ただし、競合が発生しない代わりに待機するトランザクションが多くなり、パフォーマンスの低下を招く可能性がある
- ロックの持続時間
  - 行レベルのロック: 他のトランザクションが更新するまで、ロックが保持される。
  - テーブルレベルのロック: ロックが解放されるまで、他のトランザクションがテーブルに対する操作を行うことができない。

### 悲観ロックと楽観ロック（あるいは悲観的排他制御と楽観的排他制御）の違い

- 悲観ロックと楽観ロックは、両者とも排他制御の方法であり、同時に複数のトランザクションが同じリソースにアクセスして競合が生じることを防止するために使用される。しかし、その方法論には大きな違いがある。
- 悲観ロックは、リソースを利用する際に常にロックをかける方法。つまり、トランザクションがリソースを利用する際に、他のトランザクションが利用中である場合は待機するようにして、リソースに対して排他的なアクセス権を獲得する。悲観ロックは、トランザクションが競合することをあらかじめ予測し、それを回避するために行われる。悲観ロックの代表的な実装として、データベースにおける共有ロックや排他ロックがある。
- 楽観ロックは、トランザクションがリソースにアクセスした際にロックをかけず、リソースを読み取った後に更新を行う前に、他のトランザクションがそのリソースを更新していないかどうかを確認する方法。つまり、トランザクションがリソースを更新する際に、他のトランザクションがリソースを更新していないかを確認することで、競合を回避する。楽観ロックは、トランザクションが競合しないことを前提とし、トランザクションの実行中にはリソースを占有しないため、処理性能が高くなる傾向がある。楽観ロックの代表的な実装として、データベースにおけるバージョニングやタイムスタンプ制御がある。
- 楽観ロックは、競合が起こることが少ない場合に有効であり、データの一貫性を維持しながら、高いパフォーマンスを実現することができる。一方、悲観ロックは競合が起こる可能性が高い場合に有効であり、他のトランザクションとの同時アクセスを抑制することができるが、パフォーマンスが低下することがある。

### 共有ロックと排他ロックの違いを説明してください

- 悲観ロックの代表的な実装として、データベースにおける共有ロックと排他ロック。これらは、トランザクションがデータを利用する際に使用され、トランザクション同士の競合を回避するために必要とされるロック方式。
- 共有ロックは、複数のトランザクションが同時に同じデータを読み取ることができるようにするために使用される。共有ロックを取得するトランザクションは、読み取り操作を行う際にリソースに対してロックをかける。共有ロックをかけたトランザクション同士は、競合することなく同時にデータを読み取ることができる。ただし、共有ロックがかかっているデータに対して更新操作を行うトランザクションが存在する場合は、待機する必要がある。これは、共有ロックが更新操作をブロックする排他ロックと競合するため。
- 排他ロックは、トランザクションがデータを更新する際に使用される。排他ロックを取得するトランザクションは、リソースに対して排他的なアクセス権を獲得し、他のトランザクションから更新操作をブロックする。排他ロックがかかっているデータを更新するトランザクションは、データの整合性を保つために他のトランザクションがデータを変更することを防ぐ。排他ロックは、トランザクションが競合することをあらかじめ予測し、競合を回避するために行われる。
- 共有ロックと排他ロックは、トランザクションがデータを利用する際に使用され、データの整合性を保つために必要なロック方式。共有ロックは読み取り操作を行う際に使用され、複数のトランザクションが同時にデータを読み取ることができる。一方、排他ロックは更新操作を行う際に使用され、トランザクション同士の競合を回避するために必要。
- SELECT ... FOR UPDATE を実行すると、トランザクションは対象となる行に排他ロックをかける。これにより、他のトランザクションからその行を更新することができなくなり、トランザクションが処理を完了するまで待機する必要がある。

### fuzzy(non-repeatable)-read と phantom-read の違い

- Fuzzy(non-repeatable)-read: トランザクション内で同じクエリを実行しても、結果が異なってしまう現象。この問題が発生する原因は、トランザクションの実行中に他のトランザクションが同じデータを更新することによるもの。例えば、トランザクションがある行を読み取った後に、他のトランザクションがその行を更新した場合、トランザクションは異なる値を読み取ることになる。
- Phantom-read: トランザクション内で同じクエリを実行しても、結果が異なってしまう現象。この問題が発生する原因は、トランザクションの実行中に他のトランザクションがデータを追加または削除したことによるもの。例えば、トランザクションがある範囲のデータを読み取った後に、他のトランザクションがその範囲内に新しい行を追加した場合、トランザクションは異なる行を読み取ることになる。
- したがって、Fuzzy(non-repeatable)-read は更新操作が原因で起こり、Phantom-read は追加または削除操作が原因で起こる。これらの問題を回避するためには、トランザクション分離レベルを適切に設定する必要がある。たとえば、Serializable レベルでは Phantom-read も Fuzzy(non-repeatable)-read も発生しないことが保証されているが、同時にパフォーマンスも低下するため、トランザクションの目的や要件に応じて最適なトランザクション分離レベルを選択する必要がある。

## 課題２（実装）

### DirtyRead 発生手順

- トランザクション A を開始する。
- トランザクション A 内で、ある行のデータを更新するが、まだコミットしない。この時点で、他のトランザクションからはまだ更新前の値が見えている。
- トランザクション B を開始する。
- トランザクション B 内で、トランザクション A が更新した行のデータを読み取る。この時点で、トランザクション B からはトランザクション A が更新した値が見える。
- トランザクション A がコミットするかロールバックするかにかかわらず、トランザクション B からは更新前または更新後のどちらかの値が見える。

```
-- トランザクションA
BEGIN TRANSACTION;
UPDATE my_table SET column1 = 'new_value' WHERE id = 1;

-- トランザクションB
BEGIN TRANSACTION;
SELECT column1 FROM my_table WHERE id = 1;
```

この場合、トランザクション B は、トランザクション A がコミットする前にトランザクション A が更新したデータを読み取ってしまうため、Dirty Read が発生する。

### Non-repeatable read 発生手順

- トランザクション A を開始する。
- トランザクション A 内で、ある行のデータを読み取る。
- トランザクション B を開始する。
- トランザクション B 内で、トランザクション A が読み取った行のデータを更新する。
- トランザクション A が再度同じ行のデータを読み取る。この時点で、トランザクション A からは異なる値が見えます。

```
-- トランザクションA
BEGIN TRANSACTION;
SELECT column1 FROM my_table WHERE id = 1;

-- トランザクションB
BEGIN TRANSACTION;
UPDATE my_table SET column1 = 'new_value' WHERE id = 1;

-- トランザクションA
SELECT column1 FROM my_table WHERE id = 1;
```

この場合、トランザクション A が最初に行った SELECT 文では、トランザクション B によって更新されていない値を読み取る。
しかし、トランザクション B によって更新された後にトランザクション A が再度同じ行のデータを読み取ると、更新された値が読み取られる。
これにより、Non-repeatable read が発生する。

### Phantom read 発生手順

- トランザクション A を開始する。
- トランザクション A 内で、ある範囲のデータを読み取る。
- トランザクション B を開始する。
- トランザクション B 内で、トランザクション A が読み取った範囲に新しい行を追加する。
- トランザクション A が再度同じ範囲のデータを読み取る。この時点で、トランザクション A からは新しい行が見えます。

```
-- トランザクションA
BEGIN TRANSACTION;
SELECT column1 FROM my_table WHERE column2 BETWEEN 10 AND 20;

-- トランザクションB
BEGIN TRANSACTION;
INSERT INTO my_table (column1, column2) VALUES ('new_value', 15);

-- トランザクションA
SELECT column1 FROM my_table WHERE column2 BETWEEN 10 AND 20;
```

この場合、トランザクション A が最初に行った SELECT 文では、トランザクション B によって追加された新しい行が含まれていない。
しかし、トランザクション B によって新しい行が追加された後にトランザクション A が再度同じ範囲のデータを読み取ると、新しい行が含まれる。
これにより、Phantom read が発生する。

### 多重予約が発生する可能性が低い状況の映画のチケットを販売するシステム

- 楽観ロックを利用することが適切
- 映画の予約が限られた端末でしか行われないため、複数のユーザーが同時に同じ映画のチケットを予約する可能性が非常に低いため
- つまり、競合が発生する可能性が低いため、楽観ロックによる競合解決が効率的であると考えられる
- 楽観ロックを用いた映画のチケット予約システムのアプリケーションの流れ
  - 顧客が端末を使ってチケット予約を開始する。
  - システムがチケット情報を読み込み、顧客に表示する。
  - 顧客が席を選択し、予約を確定する。
  - システムがチケット情報のバージョン番号を確認し、変更されていないかどうかチェックする。
  - バージョン番号が一致する場合、予約を更新し、バージョン番号をインクリメントする。
  - バージョン番号が一致しない場合、競合が発生したと判断し、エラーメッセージを表示する。
- 楽観ロックによる実装例として、チケット情報にバージョン番号を設定し、予約更新時にバージョン番号が一致するか確認する方法の TypeScript サンプルコード

```
interface Ticket {
  id: number;
  seatNumber: string;
  reserved: boolean;
  version: number;
}

async function getTicketById(ticketId: number): Promise<Ticket> {
  // 画面上で表示するために、データベースからチケット情報を取得します。
}

async function reserveTicket(ticketId: number, seatNumber: string): Promise<Ticket> {
  const ticket = await getTicketById(ticketId);

  if (ticket.reserved) {
    throw new Error("This seat has already been reserved.");
  }

  const updatedTicket = await updateTicketWithRetry(ticket, seatNumber);
  return updatedTicket;
}

async function updateTicketWithRetry(ticket: Ticket, seatNumber: string, retryCount: number = 3): Promise<Ticket> {
  try {
    const updatedTicket = await updateTicket(ticket, seatNumber);
    return updatedTicket;
  } catch (error) {
    if (retryCount === 0) {
      throw error;
    }
    // 競合が発生した場合、再度最新のチケット情報を取得してリトライします。
    const latestTicket = await getTicketById(ticket.id);
    return await updateTicketWithRetry(latestTicket, seatNumber, retryCount - 1);
  }
}

async function updateTicket(ticket: Ticket, seatNumber: string): Promise<Ticket> {
  const currentTicket = await getTicketById(ticket.id);

  // 取得時と更新時のバージョン番号が一致しない場合、競合が発生したと判断します。
  if (currentTicket.version !== ticket.version) {
    throw new Error("A conflict occurred while reserving the ticket. Please try again.");
  }

  ticket.reserved = true;
  ticket.seatNumber = seatNumber;
  ticket.version++;

  // ここで、データベースにチケット情報を更新します。

  return ticket;
}
```

### 外部 API を用いた決済と自分たちが管理している DB への永続化を行う場合、どちらを先に実施するのが良い？

- 外部 API を用いた決済をロールバックすることは難しいので、自分達が管理している DB への永続化を先に行うべき

### 「1 つの Parent に紐づく Child は 5 つまで」というルールを厳格に守る必要がある場合

下記の流れで、Child が 5 つまでしか Parent に紐づかないように制限できる

- トランザクションを開始する。
- Parent に紐づく Child の数をカウントする。これを行う際に親子の間に存在する関連テーブル（例: ParentChildRelation）に対して排他ロック（Exclusive Lock）を取得する。
- Child の数が 5 未満であることを確認する。
- 新しい Child を作成し、Parent に紐付ける。
- トランザクションをコミットする。

このアプローチにより、複数のクライアントから同時にリクエストがあっても、トランザクションが正しく管理され、一度に 1 つのクライアントだけが Child を作成し、Parent に紐付けることができる。これにより、5 つより多くの Child が Parent に紐づくことはない。排他ロックを使用する場合、他のクライアントは関連テーブルにアクセスできなくなるため。

下記は、排他ロックを TypeScript, Prisma で実装したサンプルコード

```
import { PrismaClient, Prisma } from "@prisma/client";

const prisma = new PrismaClient();

async function addChildToParent(parentId: number, childData: Prisma.ChildCreateInput) {
  await prisma.$transaction(async (prisma) => {
    // ParentChildRelationに排他ロックをかける
    await prisma.$executeRawUnsafe(`SELECT * FROM "ParentChildRelation" WHERE "parentId" = $1 FOR UPDATE`, [parentId]);

    // Parentに紐づくChildの数をカウント
    const childCount = await prisma.parentChildRelation.count({
      where: {
        parentId: parentId,
      },
    });

    // Childの数が5未満であることを確認
    if (childCount >= 5) {
      throw new Error("A parent can have a maximum of 5 children.");
    }

    // 新しいChildを作成し、ParentChildRelationテーブルにレコードを追加
    const newChild = await prisma.child.create({ data: childData });
    await prisma.parentChildRelation.create({
      data: {
        parentId: parentId,
        childId: newChild.id,
      },
    });
  });
}

```

# 課題 3（クイズ）

ACID 特性とは、どのような特性を表しているか?
