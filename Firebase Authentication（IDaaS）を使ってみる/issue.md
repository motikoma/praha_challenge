# 課題 1

「特大課題」でモデリングしたプラハチャレンジのサービスには既に Nest.js で認証認可を実装済みだったので、
今回は新しくリポジトリを作成して、Firebase Authentication（IDaaS）を使う。

1.firebaseAdminSDK の秘密鍵である firebaseSecretKey.json は、Firebase のコンソールから取得する。
2.Google アカウントでログイン
3.API リクエストボタンを押す

結果: API リクエスト時に送付した JWT トークンが、サーバー側で検証され、API から 200 が返却される。
https://gyazo.com/9fbb956d22d119e526e0a7fdbab5ea08

# 課題 2

## セッションベースの認証

セッションベースの認証は、従来のウェブアプリケーションでよく使われる方法
ユーザーがログインすると、サーバー側で生成したセッション ID をクライアントのクッキーに保存する
クライアントはセッション ID をリクエストごとにサーバーに送信し、サーバーはセッション ID を使用してユーザーを識別する
ステートフルな通信ができる
セッション ID が流出した場合でも無効化ができる
通常の Web アプリケーションで採用することが多い

## トークンベースの認証

トークンベースの認証は、近年よく使われる認証の方法。特に SPA やモバイルアプリなどでよく使用される
ユーザーがログインすると、サーバーからトークン（アクセストークンやリフレッシュトークンなど）が発行される
クライアントはリクエストごとにトークンをサーバーに送信する
サーバーはトークンを検証し、トークンに含まれる情報を使ってユーザーを認証する
ステートレスでスケールしやすい
トークンが流出した場合、無効化ができない
不特定多数のクライアントを認証する必要がある API では、スケーラビリティの観点からこちらが採用されることが多い

## 比較と利点

両者の最も大きな違いは、セッションベース認証がサーバーに認証のための情報 (セッション ID とユーザー情報の対応) を持たせておくのに対し、トークンベース認証はサーバーにそうした情報を持たせずトークンの検証のみによって認証を行う点
セッションベース認証はステートフルであり、トークンベース認証はステートレスであるということ
セッションベース認証がステートフルな通信を実現できるというメリットを持つ一方で、トークンベース認証は (サーバーに認証のための情報を持つ必要がないため) ユーザーが増加した時のサーバー負荷がセッションベース認証よりも少なく、よりスケーラブルなシステムを実現できるというメリットを持つ。

## アクセストークンが盗まれて不正ログインされた場合の対策

### アクセストークンの有効期限を短くする

- アクセストークンの有効期限を短く設定することで、盗まれたアクセストークンの悪用期間を短縮できる
- 一般的に、長期間のアクセストークンを発行するのではなく、数分や数時間などの短い期間で有効期限を設定する

### 二要素認証を導入する

- パスワードだけでなく、二要素認証（2FA）を導入することで、不正ログインを防止できる
- 2FA は、何かしらの追加情報（SMS での確認コード、ワンタイムパスワード、セキュリティキーなど）を要求し、セキュリティを強化する

### 不正ログインの検知とアラート

- ログイン時やアクセス時に異常なアクティビティを検知するシステムを導入し、不正ログインを検知した場合は適切なアラートを発行することで早期に対応できる。

### セッション管理の監視

- アクセストークンによるセッション管理の監視を行い、不正なセッションの検知と対応を行う。

## 参考

https://zenn.dev/tanaka_takeru/articles/3fe82159a045f7
