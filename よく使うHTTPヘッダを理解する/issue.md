# 課題 1

## HTTP ヘッダー

- HTTP ヘッダーにより、 HTTP リクエストやレスポンスでクライアントやサーバーが追加情報を渡すことができる
- HTTP ヘッダーは、大文字小文字を区別しないヘッダー名とそれに続くコロン (:)、 値で構成される。値の前にあるホワイトスペースは無視される
- ヘッダーはコンテキストに応じて分離できる
  - リクエストヘッダーは、読み込むリソースについての情報や、そのリソースをリクエストしているクライアントに関する詳細な情報を持つ
  - レスポンスヘッダーは、レスポンスに関する追加情報、例えば場所や提供しているサーバーに関する情報を保持する
  - 表現ヘッダーは、リソースの本体に関する情報、例えば MIME タイプや適用されるエンコード／圧縮方式などについての情報を持つ
  - ペイロードヘッダー (en-US)は、転送されるデータの表現から独立した情報、例えばコンテンツの長さや転送に使われるエンコード方式などを持つ

## Host

- Host は HTTP/1.1 から導入された HTTP リクエストヘッダーで、リクエストが送信される先のサーバーとポート番号を指定する
- 一つの物理的なサーバーが複数のドメイン（バーチャルホスト）をホストしている場合に、どのドメインにリクエストをルーティングするかをサーバーに伝えるために使用されます。
- Host: www.example.com
- 上記の例では、クライアントはリクエストをwww.example.comというドメインに送信することを指定している
- HTTP/1.1 以降では、Host ヘッダーは必須であり、それがないと HTTP リクエストは不完全とみなされる
- ウェブサーバーが複数のウェブサイト（バーチャルホスト）をホストすることが一般的になったため

## Content-type

- Content-Type 表現ヘッダーは、リソースのメディア種別を示すために使用する
- レスポンスにおいては、 Content-Type ヘッダーはクライアントに返されたコンテンツの実際の種類を伝える
- ブラウザーは MIME を推定し、このヘッダーの値に従わないこともあるが、sdX-Content-Type-Options を nosniff に設定すると、この動作を防ぐことができる
- リクエストにおいては (POST または PUT などで)、クライアントがサーバーに実際に送ったデータの種類を伝えます。

## User-agent

- User-Agent リクエストヘッダーは、サーバーやネットワークピアがアプリケーション、オペレーティングシステム、ベンダーや、リクエストしているユーザーエージェントのバージョン等を識別できるようにする特性文字列

## Accept

- HTTP の Accept リクエストヘッダーは、クライアントが理解できるコンテンツタイプを MIME タイプで伝える
- コンテンツネゴシエーションを使用して、サーバーは提案のうちの一つを選択し、それを使用してクライアントに Content-Type レスポンスヘッダーで選択を伝える
- ブラウザーはリクエストを行う場面に応じて適切な値をこのヘッダーに設定する
- CSS スタイルシートを取得するときは、画像、動画、スクリプトを取得するときとは異なる値をリクエストで設定する

## Referer

- Referer リクエストヘッダーには、現在リクエストされているページへのリンク先を持った直前のウェブページのアドレスが含まれている
- Referer ヘッダーにより、サーバーは人々がどこから訪問しに来たかを識別し、分析、ログ、キャッシュの最適化などに利用することができる

## Accept-Encoding

- Accept-Encoding は HTTP のリクエストヘッダーで、クライアントが理解することができるコンテンツのエンコーディング（ふつうは圧縮アルゴリズム）を示す
- コンテンツ交渉を使用して、サーバーは提案されたものから一つを選択して使用し、 Content-Encoding レスポンスヘッダーを使用してクライアントに選択結果を知らせる
- クライアントとサーバーが同じ圧縮アルゴリズムに対応していた場合でも、 identity の値が受け付けられる場合は、サーバーはレスポンスの本体を圧縮しないことを選択する場合がある。
- これには主に 2 つの場合がある
  - 送信されるデータがすでに圧縮されており、 2 回目の圧縮によって送信するデータが小さくならない場合。これは圧縮を伴う画像形式（JPEG など）が該当する
  - サーバーが過負荷になってもり、圧縮に必要な計算上のオーバーヘッドの余裕がない場合。通常、 Microsoft はサーバーが計算能力の 80% 以上を使用している場合、圧縮しないことを推奨している
- identity の値、つまりエンコードをしないということは、 identity;q=0 または \*;q=0 で identity とは別な値が明確に設定されていない限り、サーバーは 406 Not Acceptable エラーを返してはいけない。

## Authorization

- HTTP の Authorization リクエストヘッダーは、ユーザーエージェントがサーバーから認証を受けるための証明書を保持する

## Location

- Location 応答ヘッダーはページをリダイレクトする URL を示す。3xx(リダイレクト)または 201(作成)ステータスレスポンスで提供されるときのみ意味を持つ。
- リダイレクトの場合、Location が指すページを取得するための新しいリクエストに使われる HTTP メソッドは、元のメソッドとリダイレクトの種類に依存する
  - 303 (See Other)応答は常に GET メソッドの使用する
  - 307 (Temporary Redirect) と 308 (Permanent Redirect) は元のリクエストで使われたメソッドを変更しない
  - 301 (Moved Permanently) と 302 (Found) は、ほとんどの場合メソッドを変更しないが、古いユーザーエージェントは変更する可能性がある

## a タグに target="\_blank"を設定する際に、rel="noopener noreferrer"を設定する理由

- rel="noreferrer"を設定する理由は、主にセキュリティとプライバシーの観点
- a タグに target="\_blank"を設定すると、リンクは新しいタブまたはウィンドウで開く
- 例えば、ユーザーが秘密の情報を含む URL からリンクをクリックした場合、その秘密の情報が参照先のサーバーに漏洩する可能性がある
- これを防ぐために、rel="noreferrer"を設定することで、ブラウザに Referer ヘッダーを送信しないよう指示することができる

## 同じオリジンの時は referer の情報を全部送って、別オリジンの時は、オリジン情報だけを referer として送信する

- 要求されている動作には、Referer-Policy ヘッダーに strict-origin-when-cross-origin という値を設定する
- 同じオリジンへのナビゲーション：完全な URL が Referer として送信される
- 別オリジンへのナビゲーション：オリジン情報だけが Referer として送信されます。パスとクエリストリングは削除される

```
Referer-Policy: strict-origin-when-cross-origin
```

# 課題 2

### 「Accept-Encoding」ヘッダーについて

- このヘッダーがない場合、サーバーはどのようなエンコーディングを使用してレスポンスを送信するべきでしょうか？

### 「If-Modified-Since」ヘッダーについて

- HTTP リクエストヘッダーの「If-Modified-Since」はどのような目的で使用されますか？また、このヘッダーが存在する場合、サーバーはどのようなレスポンスを返すべきでしょうか？

### 「Referer」ヘッダーと「Origin」ヘッダーの違いについて

「Referer」ヘッダーと「Origin」ヘッダーの主な違いは何でしょうか？また、それぞれが主にどのような目的で使用されるでしょうか？

# 課題 3（クイズ）

## Twitter のフォロー関係の破棄

- リソースの削除を表すため DELETE で行うべき

## 取引の取り消し

- 取引の取り消しはその取引を無効化する操作であり、記録として残したいのであれば、POST メソッドを使用するべき
- 取引の記録自体を完全に削除する操作であるならば、これはリソースの削除に相当するため、HTTP の DELETE メソッドを使用するべき

## お気に入りリストからの削除

- リソースの削除を表すため DELETE で行うべき
- リスト内の特定のアイテムを変更すると捉えることもできるので、その場合は PATCH メソッドを使用する
